{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SignalsService - KuperStudio SignalsService is a simple signal system that will facilitate the connection of multiple scripts or for return systems like DataStores where you can receive '.Changed' as a connection type. What are the benefits the service gives? A simple and easy-to-learn system. It provides multiple connections between scripts that makes it easier and better to use them. Derivation and typing that amplifies your working area. Secure and optimized code, without the need for instantiations or anything that worsens the performance of your code. Why should I use SignalsService? SignalsService brings a large and clean workspace that facilitates the connection of multiple scripts and optimizes your code, thus giving you more security. SignalsService was developed by HottylewrSlip! Service documentation: API Devforum Discussion Topic: Topic Roblox Library: Library GitHub Repository: Repository","title":"Home"},{"location":"#signalsservice-kuperstudio","text":"SignalsService is a simple signal system that will facilitate the connection of multiple scripts or for return systems like DataStores where you can receive '.Changed' as a connection type.","title":"SignalsService - KuperStudio"},{"location":"#what-are-the-benefits-the-service-gives","text":"A simple and easy-to-learn system. It provides multiple connections between scripts that makes it easier and better to use them. Derivation and typing that amplifies your working area. Secure and optimized code, without the need for instantiations or anything that worsens the performance of your code.","title":"What are the benefits the service gives?"},{"location":"#why-should-i-use-signalsservice","text":"SignalsService brings a large and clean workspace that facilitates the connection of multiple scripts and optimizes your code, thus giving you more security. SignalsService was developed by HottylewrSlip! Service documentation: API Devforum Discussion Topic: Topic Roblox Library: Library GitHub Repository: Repository","title":"Why should I use SignalsService?"},{"location":"api/","text":"API SignalsService SignalsService.new() local Signal = SignalsService . new ( 'Signal' ) The function '.new' serves to connect to signals based on the some entered as argument. Note The signal system will not work if you want to make a connection between server and client, because Roblox services do not allow this. It is recommended that you use RemoteEvents or RemoteFunctions if you want to make a connection between server and client. Signal Signal:Connect() Signal : Connect ( function ( A , B ) print ( A + B ) end ) Connects to the signal service waiting for a fire to load the callback function. Signal:ConnectParallel() Signal : ConnectParallel ( function ( A , B ) print ( A + B ) end ) It connects to the signal service waiting for a fire to load the callback function in a parallel manner, thus not interfering with your current code. Note This service will typically be used to load map chunks, visual effects, call waiting and so on. Signal:Wait() local Result = Signal : Wait () print ( Result ) It waits for a connection fire and returns the received values. Warning It should be noted that this function interrupts all loading of your current code. Signal:Fire() Signal : Fire ( 5 , 5 ) Fires the current signal system connections. Signal:OnInvoke() Signal : OnInvoke ( function ( A , B ) return A + B end ) Creates a callback function that will be activated after invoking the signal that will receive the function's callback. Signal:Invoke() local Result = Signal : Invoke ( 5 , 5 ) print ( Result ) Wait until the 'OnInvoke' function exists and then invoke it by entering the necessary arguments to the function and thus receiving the function's return. Signal:Destroy() Signal : Destroy () It will destroy all the connections in the signal system. Warning This function can generate an error in your code if you exclude running functions like 'Wait' or 'Invoke'.","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#signalsservice","text":"","title":"SignalsService"},{"location":"api/#signalsservicenew","text":"local Signal = SignalsService . new ( 'Signal' ) The function '.new' serves to connect to signals based on the some entered as argument. Note The signal system will not work if you want to make a connection between server and client, because Roblox services do not allow this. It is recommended that you use RemoteEvents or RemoteFunctions if you want to make a connection between server and client.","title":"SignalsService.new()"},{"location":"api/#signal","text":"","title":"Signal"},{"location":"api/#signalconnect","text":"Signal : Connect ( function ( A , B ) print ( A + B ) end ) Connects to the signal service waiting for a fire to load the callback function.","title":"Signal:Connect()"},{"location":"api/#signalconnectparallel","text":"Signal : ConnectParallel ( function ( A , B ) print ( A + B ) end ) It connects to the signal service waiting for a fire to load the callback function in a parallel manner, thus not interfering with your current code. Note This service will typically be used to load map chunks, visual effects, call waiting and so on.","title":"Signal:ConnectParallel()"},{"location":"api/#signalwait","text":"local Result = Signal : Wait () print ( Result ) It waits for a connection fire and returns the received values. Warning It should be noted that this function interrupts all loading of your current code.","title":"Signal:Wait()"},{"location":"api/#signalfire","text":"Signal : Fire ( 5 , 5 ) Fires the current signal system connections.","title":"Signal:Fire()"},{"location":"api/#signaloninvoke","text":"Signal : OnInvoke ( function ( A , B ) return A + B end ) Creates a callback function that will be activated after invoking the signal that will receive the function's callback.","title":"Signal:OnInvoke()"},{"location":"api/#signalinvoke","text":"local Result = Signal : Invoke ( 5 , 5 ) print ( Result ) Wait until the 'OnInvoke' function exists and then invoke it by entering the necessary arguments to the function and thus receiving the function's return.","title":"Signal:Invoke()"},{"location":"api/#signaldestroy","text":"Signal : Destroy () It will destroy all the connections in the signal system. Warning This function can generate an error in your code if you exclude running functions like 'Wait' or 'Invoke'.","title":"Signal:Destroy()"},{"location":"documentation/basicusage/","text":"Basic Usage After setting up the service, we can now learn more about our service and put each system into practice. Requiring To get started we will be calling our module depending on how we set it up. --// Services local ReplicatedStorage = game : GetService ( 'ReplicatedStorage' ) --// SignalsService local SignalsService = require ( ReplicatedStorage . SignalsService ) For the require we are calling the service ReplicatedStorage and after that requiring the module SignalsService that we insert in ReplicatedStorage. Creating Signals Creation is the most important part when it comes to our events, because creation allows us to manipulate events in the way we want and when we want. local Event = SignalsService . new ( 'Event' ) To create an event we just need to make our service call with .new and insert the argument in string format to declare the name of our event. Use of Signals After the creation of our signals we can start using them the way we want, an example of this would be to make an event that every time it is loaded it will give a response that will be the sum of the first two arguments. Event : Connect ( function ( A : number , B : number ) print ( A + B ) end ) To fire the connection made above, we need to use the Fire function which will trigger all connections present in the current signal. Event : Fire ( 5 , 5 ) If we just want a firing check, we can use Wait which will interrupt the script until there is a firing of the current signal connections. Event : Wait () Warning This function will stop your current code until there is an event firing. Use it very carefully and usually in multiple script signals, so that there are no future problems with your code. In addition to connections, there are also invocations that can only be set once and when invoked, the invoker will receive the return function of the current invocation. Event : OnInvoke ( function ( A + B ) return A + B end ) local Result = Event : Invoke ( 5 , 5 ) print ( Result ) -- 10 This example shows that Result is the result of the value A + B received as a return from the function entered in OnInvoke .","title":"Basic Usage"},{"location":"documentation/basicusage/#basic-usage","text":"After setting up the service, we can now learn more about our service and put each system into practice.","title":"Basic Usage"},{"location":"documentation/basicusage/#requiring","text":"To get started we will be calling our module depending on how we set it up. --// Services local ReplicatedStorage = game : GetService ( 'ReplicatedStorage' ) --// SignalsService local SignalsService = require ( ReplicatedStorage . SignalsService ) For the require we are calling the service ReplicatedStorage and after that requiring the module SignalsService that we insert in ReplicatedStorage.","title":"Requiring"},{"location":"documentation/basicusage/#creating-signals","text":"Creation is the most important part when it comes to our events, because creation allows us to manipulate events in the way we want and when we want. local Event = SignalsService . new ( 'Event' ) To create an event we just need to make our service call with .new and insert the argument in string format to declare the name of our event.","title":"Creating Signals"},{"location":"documentation/basicusage/#use-of-signals","text":"After the creation of our signals we can start using them the way we want, an example of this would be to make an event that every time it is loaded it will give a response that will be the sum of the first two arguments. Event : Connect ( function ( A : number , B : number ) print ( A + B ) end ) To fire the connection made above, we need to use the Fire function which will trigger all connections present in the current signal. Event : Fire ( 5 , 5 ) If we just want a firing check, we can use Wait which will interrupt the script until there is a firing of the current signal connections. Event : Wait () Warning This function will stop your current code until there is an event firing. Use it very carefully and usually in multiple script signals, so that there are no future problems with your code. In addition to connections, there are also invocations that can only be set once and when invoked, the invoker will receive the return function of the current invocation. Event : OnInvoke ( function ( A + B ) return A + B end ) local Result = Event : Invoke ( 5 , 5 ) print ( Result ) -- 10 This example shows that Result is the result of the value A + B received as a return from the function entered in OnInvoke .","title":"Use of Signals"},{"location":"documentation/settingup/","text":"Setting up SignalsService is a module, this means that to use the service you will need to request the module. For the required module we will have different options to do this. Requiring module 1. Getting by service ID Create a module in ReplicatedStorage Rename the module to SignalsService Insert a return with the require by service ID (7715453598) inside the module return require ( 7715453598 ) 2. Get it from the Roblox Library Get the library model Put the model inside ReplicatedStorage Rename the module to SignalsService 3. Get from GitHub SignalsService Repository Create a module in ReplicatedStorage Rename the module to SignalsService You must insert into the module the code mentioned below. return game : GetService ( 'HttpService' ): GetAsync ( 'https://raw.githubusercontent.com/KuperStudio/SignalsService/main/SignalsService.lua' , true )()","title":"Setting up"},{"location":"documentation/settingup/#setting-up","text":"SignalsService is a module, this means that to use the service you will need to request the module. For the required module we will have different options to do this.","title":"Setting up"},{"location":"documentation/settingup/#requiring-module","text":"","title":"Requiring module"},{"location":"documentation/settingup/#1-getting-by-service-id","text":"Create a module in ReplicatedStorage Rename the module to SignalsService Insert a return with the require by service ID (7715453598) inside the module return require ( 7715453598 )","title":"1. Getting by service ID"},{"location":"documentation/settingup/#2-get-it-from-the-roblox-library","text":"Get the library model Put the model inside ReplicatedStorage Rename the module to SignalsService","title":"2. Get it from the Roblox Library"},{"location":"documentation/settingup/#3-get-from-github","text":"SignalsService Repository Create a module in ReplicatedStorage Rename the module to SignalsService You must insert into the module the code mentioned below. return game : GetService ( 'HttpService' ): GetAsync ( 'https://raw.githubusercontent.com/KuperStudio/SignalsService/main/SignalsService.lua' , true )()","title":"3. Get from GitHub"},{"location":"examples/Connections/","text":"Connections Connections are the simplest functions when it comes to events/signals, because connections offer a fast and easy-to-use system that with just a single call you can activate over a hundred functions at the same time. The two scripts below showed an example connection that will occur between them and that one needs the other to complete, a very interesting romance story! Script-1 --// Services local SignalsService = require ( game : GetService ( 'ReplicatedStorage' ): FindFirstChild ( 'SignalsService' )) --// Signals local Adder = SignalsService . new ( 'Adder' ) --// Functions Adder : Connect ( function ( A , B ) print ( A + B ) end ) The current script is receiving the 'Adder' signal and is connecting to that signal by asking for 2 arguments that will be summed and printed. Script-2 --// Services local SignalsService = require ( game : GetService ( 'ReplicatedStorage' ): FindFirstChild ( 'SignalsService' )) --// Signals local Adder = SignalsService . new ( 'Adder' ) --// Functions task . wait ( 2 ) Adder : Fire ( 5 , 5 ) The second script has the same characteristics as the first, but this one, instead of connecting to the signal, is firing the signal and inserting two numeric arguments into the signal connections.","title":"Connections"},{"location":"examples/Connections/#connections","text":"Connections are the simplest functions when it comes to events/signals, because connections offer a fast and easy-to-use system that with just a single call you can activate over a hundred functions at the same time. The two scripts below showed an example connection that will occur between them and that one needs the other to complete, a very interesting romance story!","title":"Connections"},{"location":"examples/Connections/#script-1","text":"--// Services local SignalsService = require ( game : GetService ( 'ReplicatedStorage' ): FindFirstChild ( 'SignalsService' )) --// Signals local Adder = SignalsService . new ( 'Adder' ) --// Functions Adder : Connect ( function ( A , B ) print ( A + B ) end ) The current script is receiving the 'Adder' signal and is connecting to that signal by asking for 2 arguments that will be summed and printed.","title":"Script-1"},{"location":"examples/Connections/#script-2","text":"--// Services local SignalsService = require ( game : GetService ( 'ReplicatedStorage' ): FindFirstChild ( 'SignalsService' )) --// Signals local Adder = SignalsService . new ( 'Adder' ) --// Functions task . wait ( 2 ) Adder : Fire ( 5 , 5 ) The second script has the same characteristics as the first, but this one, instead of connecting to the signal, is firing the signal and inserting two numeric arguments into the signal connections.","title":"Script-2"},{"location":"examples/Invocations/","text":"Invocations Invocations are very important when dealing with return methods for multiple scripts, an example of this would be to collect a local variable from a secondary script where I have access only through the signals service. Script-1 --// Services local SignalsService = require ( game : GetService ( 'ReplicatedStorage' ): FindFirstChild ( 'SignalsService' )) --// Signals local GetVar = SignalsService . new ( 'GetVar' ) --// Variables local Variable = 'Hello World!' --// Functions GetVar : OnInvoke ( function () return Variable end ) The current script gets the 'GetVar' signal and sets a variable called 'Variable' with its value being 'Hello World!', right after these two calls, it takes the 'OnInvoke' variable from the 'GetVar' signal and sets it to be a function that returns the local variable defined earlier. Script-2 --// Services local SignalsService = require ( game : GetService ( 'ReplicatedStorage' ): FindFirstChild ( 'SignalsService' )) --// Signals local GetVar = SignalsService . new ( 'GetVar' ) --// Variables local Variable --// Functions Variable = GetVar : Invoke () print ( Variable ) The second script does the same as the first script, but it does not set the variable 'Variable' directly, it makes an 'Invoke' call to the 'GetVar' signal which sets the variable and then prints it.","title":"Invocations"},{"location":"examples/Invocations/#invocations","text":"Invocations are very important when dealing with return methods for multiple scripts, an example of this would be to collect a local variable from a secondary script where I have access only through the signals service.","title":"Invocations"},{"location":"examples/Invocations/#script-1","text":"--// Services local SignalsService = require ( game : GetService ( 'ReplicatedStorage' ): FindFirstChild ( 'SignalsService' )) --// Signals local GetVar = SignalsService . new ( 'GetVar' ) --// Variables local Variable = 'Hello World!' --// Functions GetVar : OnInvoke ( function () return Variable end ) The current script gets the 'GetVar' signal and sets a variable called 'Variable' with its value being 'Hello World!', right after these two calls, it takes the 'OnInvoke' variable from the 'GetVar' signal and sets it to be a function that returns the local variable defined earlier.","title":"Script-1"},{"location":"examples/Invocations/#script-2","text":"--// Services local SignalsService = require ( game : GetService ( 'ReplicatedStorage' ): FindFirstChild ( 'SignalsService' )) --// Signals local GetVar = SignalsService . new ( 'GetVar' ) --// Variables local Variable --// Functions Variable = GetVar : Invoke () print ( Variable ) The second script does the same as the first script, but it does not set the variable 'Variable' directly, it makes an 'Invoke' call to the 'GetVar' signal which sets the variable and then prints it.","title":"Script-2"}]}